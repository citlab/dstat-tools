#! /usr/bin/ruby

require 'gnuplot'
require 'csv'
require 'optparse'

"""
dstat_plot
plots csv data generated by dstat-monitor
""" 

$verbose = false

def plot(dataSets, category, field, dry, target_dir)
  Dir.chdir(target_dir)

  Gnuplot.open do |gp|
    Gnuplot::Plot.new(gp) do |plot|
      plot.title dataSets.pop
      plot.xlabel "Index"
      plot.ylabel "#{category}: #{field}"
      plot.key "out vert right top"
      
      unless dry
        plot.terminal 'png size 1600,800 enhanced font "Helvetica,11"'
        filename = "#{category}-#{field}.png".sub("/", "_")
        plot.output filename
        puts "Saving plot to '#{target_dir}/#{filename}'"
      end

      plot.data = dataSets
    end
  end
end

def read_csv(category, field, files, no_key)
  if $verbose then puts "Reading from csv." end
  gpDataSets = [] # gpDataSets = [Gnuplot::DataSet0,Gnuplot::DataSet1, ... , plotTitle]

  plotTitle = "#{category}-#{field} over time" + ' \n '
  plotTitleNotSet = true


  files.each do |file|
    CSV.open(file) do |csvFile|
      currentRow = csvFile.shift
      # loop until row with "epoch" in it is reached and read some meta data 
      # but only for the first file since there can only be one title
      while currentRow.index("epoch").nil? do
        if plotTitleNotSet
          if currentRow.index("Host:") != nil
            plotTitle += "(Host: #{currentRow[1]} User: #{currentRow[6]}"
          elsif currentRow.index("Cmdline:") != nil
            plotTitle += " Date: #{currentRow.last})"
            plotTitleNotSet = false
          end
        end
        currentRow = csvFile.shift
      end

      categoryIndex = currentRow.index(category)
    	if categoryIndex.nil?
    		puts "#{category} is not a valid parameter for 'category'. Value could not be found."
        puts "Categories: #{row.inspect}"
    		exit 1
    	end
    	
    	currentRow_at_category = csvFile.shift.drop(categoryIndex)
    	fieldIndex =  categoryIndex + currentRow_at_category.index(field)
    	if fieldIndex.nil?
    		puts "#{field} is not a valid parameter for 'field'. Value could not be found."
        puts "Fields: #{currentRow.inspect}"
    		exit 1
    	end

      # get all the interesting values and put them in an array
    	currentRow = csvFile.shift
      values = []
      until csvFile.eof do
        values.push currentRow.at(fieldIndex)
        currentRow = csvFile.shift
      end

      # create the GnuplotDataSet that is going to be printed
      x = (0..values.count-1).collect { |index| index }
      gpDataSet = Gnuplot::DataSet.new([x, values]) do |gpdataSet|
        gpdataSet.with = "lines"
        if no_key then
          gpdataSet.notitle
        else
          gpdataSet.title = File.basename file
        end
      end

      gpDataSets.push gpDataSet
    end
  end

  if $verbose then puts "gpDataSets: #{gpDataSets.count}" end

  gpDataSets.push plotTitle # the title of the entire plot is stored as the last element of the gpDataSets Array     

  gpDataSets # gpDataSets = [Gnuplot::DataSet0,Gnuplot::DataSet1,..., plotTitle]
end


def read_options_and_arguments
  options = {} # Hash that hold all the options

  optparse = OptionParser.new do |opts|
    # banner that is displayed at the top
    opts.banner = "Usage: dstat_plot.rb [options] -c CATEGORY -f FIELD [directory | file1 file2 ...]"

    ### options and what they do
    opts.on('-v', '--verbose', 'Output more information') do
      $verbose = true
    end

    options[:inverted] = false
    opts.on('-i', '--inverted', 'Invert the graph') do
      options[:inverted] = true
    end

    options[:nokey] = false
    opts.on('-n','--no-key', 'No plot key is printed') do
      options[:nokey] = true
    end

    options[:dry] = false
    opts.on('-d', '--dry', 'Dry run. Plot is not saved to file but displayed with gnuplot') do
      options[:dry] = true
    end

    options[:output] = nil
    opts.on('-o','--output PATH', 'Path where the graph should be saved to, default is csv file directory') do |path|
      options[:output] = path
    end

    options[:category] = nil
    opts.on('-c', '--category CATEGORY', 'Select the category') do |category|
      options[:category] = category
    end

    options[:field] = nil
    opts.on('-f', '--field FIELD' , 'Select the field') do |field|
      options[:field] = field
    end

    # This displays the help screen
    opts.on('-h', '--help', 'Display this screen' ) do
      puts opts
      exit
    end
  end

  # there are two forms of the parse method. 'parse' 
  # simply parses ARGV, while 'parse!' parses ARGV 
  # and removes all options and parameters found. What's
  # left is the list of files
  optparse.parse!
  if $verbose then puts "options: #{options.inspect}" end
  
  # if ARGV is empty at this point no directory or file(s) is specified
  # and the current working directory is used
  if ARGV.empty? then ARGV.push "." end

  if File.directory?(ARGV.last) then
    options[:target_dir] = ARGV.last.chomp("/") # cuts of "/" from the end if present
    files = Dir.glob "#{options[:target_dir]}/*.csv"
    puts "Plotting data from #{files.count} files."
  else
    ARGV.each do |filename|
      files.push(filename)
    end
  end
  options[:files] = files
  if $verbose then puts "files: #{files.count} #{files.inspect}" end

  if options[:output] != nil then # if an output directory is explicitly stated
    options[:target_dir] = options[:output].chomp("/")
  end

  options
end

options = read_options_and_arguments
dataSets = read_csv(options[:category], options[:field], options[:files], options[:nokey])
plot(dataSets, options[:category], options[:field], options[:dry], options[:target_dir])
